using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using UnityEngine;

public class ClassBuilder
{
    public ClassBuilder()
    {
    }

    public Type CreateClass(Type interfaceType, AssemblyName assemblyName)
    {
        AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.
            DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
        ModuleBuilder moduleBuilder = assemblyBuilder.
            DefineDynamicModule("dynamicModule");

        TypeBuilder typeBuilder = moduleBuilder.DefineType(
                String.Format("Autogenerated.{0}", interfaceType.ToString()),
                TypeAttributes.Public
            | TypeAttributes.Class
            | TypeAttributes.AutoClass
            | TypeAttributes.AnsiClass,
                typeof(System.Object));

        typeBuilder.AddInterfaceImplementation(interfaceType);
        foreach (MethodInfo methodInfo in interfaceType.GetMethods())
        {
            MethodBuilder methodBuilder = typeBuilder.DefineMethod(
                methodInfo.Name,
                MethodAttributes.Public | MethodAttributes.Virtual,
                methodInfo.ReturnType,
                this.GetMethodArguments(methodInfo));

            ILGenerator il = methodBuilder.GetILGenerator();
            typeBuilder.DefineMethodOverride(methodBuilder, methodInfo);
            this.CreateReturnValue(il, methodInfo);
            il.Emit(OpCodes.Ret);
        }

        return typeBuilder.CreateType();
    }

    private Type[] GetMethodArguments(MethodInfo methodInfo)
    {
        Type[] argumentArray = new Type[methodInfo.GetParameters().Length];
        for (int argumentIndex = argumentArray.Length - 1;
            argumentIndex >= 0; --argumentIndex)
        {
            argumentArray[argumentIndex] = methodInfo.
                GetParameters()[argumentIndex].ParameterType;
        }

        return argumentArray;
    }

    private void CreateReturnValue(ILGenerator il, MethodInfo methodInfo)
    {
        Type parameterType = methodInfo.ReturnType;
        GET attr = (GET)methodInfo.GetCustomAttributes(typeof(GET), true).FirstOrDefault();
        Debug.Log(attr.Path);
        var ctor = parameterType.GetConstructors()[0];
        if (parameterType == typeof(void))
        {
            return;
        }
        else if (parameterType.IsPrimitive || parameterType == typeof(string))
        {
            this.EmitPrimitive(il, parameterType);
        }
        else
        {
            il.Emit(OpCodes.Newobj, ctor);
            // throw new ArgumentException("Parameter was reference value or null");
        }
    }

    private void EmitPrimitive(ILGenerator il, Type parameterType)
    {
        if (parameterType == typeof(bool))
        {
            // pushes a 1 onto the stack, represents true
            il.Emit(OpCodes.Ldc_I4_1);
        }
        else if (parameterType == typeof(char))
        {
            il.Emit(OpCodes.Ldc_I4, 'a');
            il.Emit(OpCodes.Conv_I2);
        }
        else if (parameterType == typeof(int))
        {
            il.Emit(OpCodes.Ldc_I4, Convert.ToInt32(42));
        }
        else if (parameterType == typeof(long))
        {
            il.Emit(OpCodes.Ldc_I8, Convert.ToInt64(12));
        }
        else if (parameterType == typeof(double))
        {
            il.Emit(OpCodes.Ldc_R8, Convert.ToDouble(301));
        }
        else if (parameterType == typeof(string))
        {
            il.Emit(OpCodes.Ldstr, "Custom class generation worked!");
        }
        // you can add additional primitive types ad nauseum,
        // unsigned, bytes, shorts, floats, decimals, etc.
        else
        {
            throw new ArgumentException(String.Format(
                "Unsupported parameter type : {0}", parameterType));
        }
    }
}